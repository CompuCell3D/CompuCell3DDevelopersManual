Adding Python Bindings To Steppable in DeveloperZone
======================================================

In the previous example we controled entire simulation from C++. This is perfectly fine and will give you optimal
performance. However sometimes it may make sense to add Python bindings to your module . Especially if the
functions you wil call from python will not be called many times - functions calls in Python are much slower than in C++.

In addition to this if your entire code is in C++ every change you make to the code will require compilation and
installation. This is is not a big deal but takes time and is more error prone than using well designed scripting
interface. However, do not feel that you need to use Python bindings for your newly created C++ modules. They are
optional and it is perfectly fine to operate in C++ space.

Nevertheless we would like to show you how to add and use Python bindings if you feel it will be beneficial
for your simulation.

If you remember, the first step to generate steppable code using Twedit++ is to choose whether you like to add Python
bindings or not.

|dev_zone_1|

In this first dialog box we checked ``Python Wrap`` option and therefore we already generated Python bindings. They are
stored in SWIG file in ``DeveloperZone/pyinterface/CompuCellExtraModules/CompuCellExtraModules.i``:

.. code-block:: c++

    %module ("threads"=1) CompuCellExtraModules
    %include "typemaps.i"
    %include <windows.i>

    %{
    #include "ParseData.h"
    #include "ParserStorage.h"
    #include <CompuCell3D/Simulator.h>
    #include <CompuCell3D/Potts3D/Potts3D.h>

    #include <BasicUtils/BasicClassAccessor.h>
    #include <BasicUtils/BasicClassGroup.h> //had to include it to avoid problems with template instantiation


    // ********************************************* PUT YOUR PLUGIN PARSE DATA AND PLUGIN FILES HERE *************************************************

    #include <SimpleVolume/SimpleVolumePlugin.h>


    #include <VolumeMean/VolumeMean.h>

    //AutogeneratedModules1 - DO NOT REMOVE THIS LINE IT IS USED BY TWEDIT TO LOCATE CODE INSERTION POINT
    //GrowthSteppable_autogenerated


    #include <GrowthSteppable/GrowthSteppable.h>



    // ********************************************* END OF SECTION ********************************** ************************************************


    //have to include all  export definitions for modules which are arapped to avoid problems with interpreting by swig win32 specific c++ extensions...
    #define SIMPLEVOLUME_EXPORT
    #define VOLUMEMEAN_EXPORT
    //AutogeneratedModules2 - DO NOT REMOVE THIS LINE IT IS USED BY TWEDIT TO LOCATE CODE INSERTION POINT
    //GrowthSteppable_autogenerated
    #define GROWTHSTEPPABLE_EXPORT

    #include <iostream>

    using namespace std;
    using namespace CompuCell3D;

    %}

    // C++ std::string handling
    %include "std_string.i"

    // C++ std::map handling
    %include "std_map.i"

    // C++ std::map handling
    %include "std_set.i"

    // C++ std::vector handling
    %include "std_vector.i"

    //have to include all  export definitions for modules which are arapped to avoid problems with interpreting by swig win32 specific c++ extensions...
    #define SIMPLEVOLUME_EXPORT
    #define VOLUMEMEAN_EXPORT

    //AutogeneratedModules3 - DO NOT REMOVE THIS LINE IT IS USED BY TWEDIT TO LOCATE CODE INSERTION POINT
    //GrowthSteppable_autogenerated
    #define GROWTHSTEPPABLE_EXPORT

    %include <BasicUtils/BasicClassAccessor.h>
    %include <BasicUtils/BasicClassGroup.h> //had to include it to avoid problems with template instantiation

    %include "ParseData.h"
    %include "ParserStorage.h"

    // ********************************************* PUT YOUR PLUGIN PARSE DATA AND PLUGIN FILES HERE *************************************************
    // REMEMBER TO CHANGE #include to %include

    %include <SimpleVolume/SimpleVolumePlugin.h>
    // %include <SimpleVolume/SimpleVolumeParseData.h>

    // THIS IS VERY IMORTANT STETEMENT WITHOUT IT SWIG will produce incorrect wrapper code which will compile but will not work
    using namespace CompuCell3D;

    %inline %{
       SimpleVolumePlugin * reinterpretSimpleVolumePlugin(Plugin * _plugin){
          return (SimpleVolumePlugin *)_plugin;
       }

       SimpleVolumePlugin * getSimpleVolumePlugin(){
             return (SimpleVolumePlugin *)Simulator::pluginManager.get("SimpleVolume");
        }

    %}

    %include <VolumeMean/VolumeMean.h>

    %inline %{
       VolumeMean * reinterpretVolumeMean(Steppable * _steppable){
          return (VolumeMean *)_steppable;
       }

       VolumeMean * getVolumeMeanSteppable(){
             return (VolumeMean *)Simulator::steppableManager.get("VolumeMean");
        }

    %}

    //AutogeneratedModules4 - DO NOT REMOVE THIS LINE IT IS USED BY TWEDIT TO LOCATE CODE INSERTION POINT
    //GrowthSteppable_autogenerated

    %include <GrowthSteppable/GrowthSteppable.h>
    %inline %{

     GrowthSteppable * getGrowthSteppable(){

          return (GrowthSteppable *)Simulator::steppableManager.get("GrowthSteppable");
       }

    %}

We are not going to explain how SWIG wrappers work here but if you look at the file and look for occurrences of
``GrowthSteppable`` you can see that adding your own steppable to the SWIG wrapper generator is fairly easy. On top
of that if you use Twedit++ it will generate wrapper code for you.

.. note::

    At the top of the wrapper file we find ``%module ("threads"=1) CompuCellExtraModules`` . This tells us that the Python module we develop will be called ``CompuCellExtraModules``.

Adding Python-Accessible Method To GrowthSteppable
--------------------------------------------------

If we enable compilation of ``CompuCellExtraModules`` by uncommenting line ``add_subdirectory(pyinterface)`` in
``DeveloperZone/CMakeLists.txt`` we will already get GrowthSteppable bindings that we can access from
``CompuCellExtraModules``. However, they are not particularly useful because all the functions accessible via
Python are for functions that are already being used by the C++ code and, frankly it is best to leave it like that. We
need to add additional function. A reasonable choice is a function that changes growth rate for a given cell type.

First we need to add ``void setGrowthRate(unsigned int cellType, double growthRate); `` function
to ``GrowthSteppable`` header - see below:

.. code-block:: c++

    #ifndef GROWTHSTEPPABLESTEPPABLE_H
    #define GROWTHSTEPPABLESTEPPABLE_H
    #include <CompuCell3D/CC3D.h>
    #include "GrowthSteppableDLLSpecifier.h"

    namespace CompuCell3D {

        template <class T> class Field3D;
        template <class T> class WatchableField3D;

        class Potts3D;
        class Automaton;
        class BoundaryStrategy;
        class CellInventory;
        class CellG;

      class GROWTHSTEPPABLE_EXPORT GrowthSteppable : public Steppable {

        WatchableField3D<CellG *> *cellFieldG;

        Simulator * sim;

        Potts3D *potts;

        CC3DXMLElement *xmlData;

        Automaton *automaton;

        BoundaryStrategy *boundaryStrategy;

        CellInventory * cellInventoryPtr;

        Dim3D fieldDim;

      public:

        GrowthSteppable ();

        virtual ~GrowthSteppable ();

        std::map<unsigned int, double> growthRateMap;

        // SimObject interface

        virtual void init(Simulator *simulator, CC3DXMLElement *_xmlData=0);

        virtual void extraInit(Simulator *simulator);

        // Python wrapper functions

        void setGrowthRate(unsigned int cellType, double growthRate);

        //steppable interface

        virtual void start();

        virtual void step(const unsigned int currentStep);

        virtual void finish() {}


        //SteerableObject interface

        virtual void update(CC3DXMLElement *_xmlData, bool _fullInitFlag=false);

        virtual std::string steerableName();

        virtual std::string toString();

      };

    };

    #endif

Next, we add implementation of this function in the ``GrowthSteppable.cpp``:

.. code-block:: c++

    void GrowthSteppable::setGrowthRate(unsigned int cellType, double growthRate){

        cerr<<"CHANGING GROWTH RATE FOR CELL TYPE "<<cellType<<" TO "<<growthRate<<endl;
        std::map<unsigned int, double>::iterator mitr;
        this->growthRateMap[cellType] = growthRate;
    }





.. |dev_zone_1| image:: images/dev_zone_1.png
   :width: 2.4in
   :height: 1.9in